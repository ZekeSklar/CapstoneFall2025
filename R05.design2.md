## Design Part 2 — Detailed Components

### Endpoints and Routes
- Admin printer status JSON: `admin:tickets_printer_status` → `/admin/tickets/printer/<id>/status/?force=1`
- Manager feed: `/manager/status/?printer=<id>&force=1`
- All feeds set `Cache-Control: no-store` and accept `force=1`.

### Client Logic
- Admin change form: renders initial JSON (if present) then auto‑refreshes once on load; Refresh button calls the endpoint with cache‑buster.
- Manager dashboard: per‑printer and global Refresh; auto‑refresh every `poll_interval_seconds`.

### Rate Limiting Algorithm
- Window: 1 hour; Limit: 3 issue tickets per printer.
- Query: `RequestTicket.objects.filter(printer=p, type=ISSUE, created_at__gte=now-1h).count()`.
- Behavior: If over limit, accept request but do not create a new ticket; always show a “thank you” page.

### SNMP Compatibility
- Fallbacks:
  - v2c (mpModel=1) first, then v1 (mpModel=0)
  - `UdpTransportTarget.create()` if available, else constructor
  - bulk iterator vs single‑call compatibility
- Index resolution: try `hrPrinterStatus` column; fallback to `hrDeviceType` == printer.

### Caching Strategy
- Server: `no-store` on responses to avoid intermediary caching.
- Client: always append `t=Date.now()` to refresh URLs; optionally add `force=1`.

### Data Structures
- `PrinterStatus.alerts`: list of `{severity, severity_code, description, index}` (includes “Panel” lines when console text exists).
- `PrinterStatus.supplies`: list of `{description, level, max_capacity, percent}`.
- `PrinterStatus.error_flags`: list of `{label, code}` from `hrPrinterDetectedErrorState` bitfield.

### Extensibility
- Vendor OIDs: add vendor collectors in `snmp_client.py` guarded by device brand/model.
- Periodic polling: add `poll_printer_status` management command to warm caches for admin/manager views.

